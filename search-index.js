var N = null;var searchIndex = {};
searchIndex["ssh2"]={"doc":"Rust bindings to libssh2, an SSH client library.","items":[[3,"Agent","ssh2","A structure representing a connection to an SSH agent.",N,N],[3,"Identities","","An iterator over the identities found in an SSH agent.",N,N],[3,"PublicKey","","A public key which is extracted from an SSH agent.",N,N],[3,"Channel","","A channel represents a portion of an SSH connection on which data can be read and written.",N,N],[3,"ExitSignal","","Data received from when a program exits with a signal.",N,N],[12,"exit_signal","","The exit signal received, if the program did not exit cleanly. Does not contain a SIG prefix",0,N],[12,"error_message","","Error message provided by the remote server (if any)",0,N],[12,"lang_tag","","Language tag provided by the remote server (if any)",0,N],[3,"ReadWindow","","Description of the read window as returned by `Channel::read_window`",N,N],[12,"remaining","","The number of bytes which the remote end may send without overflowing the window limit.",1,N],[12,"available","","The number of bytes actually available to be read.",1,N],[12,"window_size_initial","","The window_size_initial as defined by the channel open request",1,N],[3,"WriteWindow","","Description of the write window as returned by `Channel::write_window`",N,N],[12,"remaining","","The number of bytes which may be safely written on the channel without blocking.",2,N],[12,"window_size_initial","","The window_size_initial as defined by the channel open request",2,N],[3,"Stream","","A channel can have a number of streams, each identified by an id, each of which implements the `Read` and `Write` traits.",N,N],[3,"Error","","Representation of an error that can occur within libssh2",N,N],[3,"KnownHosts","","A set of known hosts which can be used to verify the identity of a remote server.",N,N],[3,"Hosts","","Iterator over the hosts in a `KnownHosts` structure.",N,N],[3,"Host","","Structure representing a known host as part of a `KnownHosts` structure.",N,N],[3,"Listener","","A listener represents a forwarding port from the remote server.",N,N],[3,"Session","","An SSH session, typically representing one TCP connection.",N,N],[3,"ScpFileStat","","Metadata returned about a remote file when received via `scp`.",N,N],[3,"Sftp","","A handle to a remote filesystem over SFTP.",N,N],[3,"OpenFlags","","Options that can be used to configure how a file is opened",N,N],[3,"File","","A file handle to an SFTP connection.",N,N],[3,"FileStat","","Metadata information about a remote file.",N,N],[12,"size","","File size, in bytes of the file.",3,N],[12,"uid","","Owner ID of the file",3,N],[12,"gid","","Owning group of the file",3,N],[12,"perm","","Permissions (mode) of the file",3,N],[12,"atime","","Last access time of the file",3,N],[12,"mtime","","Last modification time of the file",3,N],[3,"FileType","","An structure representing a type of file.",N,N],[3,"RenameFlags","","Options to `Sftp::rename`",N,N],[4,"OpenType","","How to open a file handle with libssh2.",N,N],[13,"File","","Specify that a file shoud be opened.",4,N],[13,"Dir","","Specify that a directory should be opened.",4,N],[4,"DisconnectCode","","",N,N],[13,"HostNotAllowedToConnect","","",5,N],[13,"ProtocolError","","",5,N],[13,"KeyExchangeFailed","","",5,N],[13,"Reserved","","",5,N],[13,"MacError","","",5,N],[13,"CompressionError","","",5,N],[13,"ServiceNotAvailable","","",5,N],[13,"ProtocolVersionNotSupported","","",5,N],[13,"HostKeyNotVerifiable","","",5,N],[13,"ConnectionLost","","",5,N],[13,"ByApplication","","",5,N],[13,"TooManyConnections","","",5,N],[13,"AuthCancelledByUser","","",5,N],[13,"NoMoreAuthMethodsAvailable","","",5,N],[13,"IllegalUserName","","",5,N],[4,"HostKeyType","","",N,N],[13,"Unknown","","",6,N],[13,"Rsa","","",6,N],[13,"Dss","","",6,N],[4,"MethodType","","",N,N],[13,"Kex","","",7,N],[13,"HostKey","","",7,N],[13,"CryptCs","","",7,N],[13,"CryptSc","","",7,N],[13,"MacCs","","",7,N],[13,"MacSc","","",7,N],[13,"CompCs","","",7,N],[13,"CompSc","","",7,N],[13,"LangCs","","",7,N],[13,"LangSc","","",7,N],[4,"HashType","","",N,N],[13,"Md5","","",8,N],[13,"Sha1","","",8,N],[4,"KnownHostFileKind","","",N,N],[13,"OpenSSH","","",9,N],[4,"CheckResult","","Possible results of a call to `KnownHosts::check`",N,N],[13,"Match","","Hosts and keys match",10,N],[13,"Mismatch","","Host was found, but the keys didn't match!",10,N],[13,"NotFound","","No host match was found",10,N],[13,"Failure","","Something prevented the check to be made",10,N],[4,"KnownHostKeyFormat","","",N,N],[13,"Rsa1","","",11,N],[13,"SshRsa","","",11,N],[13,"SshDss","","",11,N],[5,"init","","Initialize the libssh2 library.",N,[[]]],[11,"connect","","Connect to an ssh-agent running on the system.",12,[[["self"]],["result",["error"]]]],[11,"disconnect","","Close a connection to an ssh-agent.",12,[[["self"]],["result",["error"]]]],[11,"list_identities","","Request an ssh-agent to list of public keys, and stores them in the internal collection of the handle.",12,[[["self"]],["result",["error"]]]],[11,"identities","","Get an iterator over the identities of this agent.",12,[[["self"]],["identities"]]],[11,"userauth","","Attempt public key authentication with the help of ssh-agent.",12,[[["self"],["str"],["publickey"]],["result",["error"]]]],[11,"drop","","",12,[[["self"]]]],[11,"next","","",13,[[["self"]],["option",["result"]]]],[11,"blob","","Return the data of this public key.",14,N],[11,"comment","","Returns the comment in a printable format",14,[[["self"]],["str"]]],[11,"clone","","",1,[[["self"]],["readwindow"]]],[11,"clone","","",2,[[["self"]],["writewindow"]]],[11,"setenv","","Set an environment variable in the remote channel's process space.",15,[[["self"],["str"],["str"]],["result",["error"]]]],[11,"request_pty","","Request a PTY on an established channel.",15,[[["self"],["str"],["option",["str"]],["option"]],["result",["error"]]]],[11,"request_pty_size","","Request a PTY of a specified size",15,[[["self"],["u32"],["u32"],["option",["u32"]],["option",["u32"]]],["result",["error"]]]],[11,"exec","","Execute a command",15,[[["self"],["str"]],["result",["error"]]]],[11,"shell","","Start a shell",15,[[["self"]],["result",["error"]]]],[11,"subsystem","","Request a subsystem be started.",15,[[["self"],["str"]],["result",["error"]]]],[11,"process_startup","","Initiate a request on a session type channel.",15,[[["self"],["str"],["option",["str"]]],["result",["error"]]]],[11,"stderr","","Get a handle to the stderr stream of this channel.",15,[[["self"]],["stream"]]],[11,"stream","","Get a handle to a particular stream for this channel.",15,[[["self"],["i32"]],["stream"]]],[11,"exit_status","","Returns the exit code raised by the process running on the remote host at the other end of the named channel.",15,[[["self"]],["result",["i32","error"]]]],[11,"exit_signal","","Get the remote exit signal.",15,[[["self"]],["result",["exitsignal","error"]]]],[11,"read_window","","Check the status of the read window.",15,[[["self"]],["readwindow"]]],[11,"write_window","","Check the status of the write window.",15,[[["self"]],["writewindow"]]],[11,"adjust_receive_window","","Adjust the receive window for a channel by adjustment bytes.",15,[[["self"],["u64"],["bool"]],["result",["u64","error"]]]],[11,"eof","","Check if the remote host has sent an EOF status for the selected stream.",15,[[["self"]],["bool"]]],[11,"send_eof","","Tell the remote host that no further data will be sent on the specified channel.",15,[[["self"]],["result",["error"]]]],[11,"wait_eof","","Wait for the remote end to send EOF.",15,[[["self"]],["result",["error"]]]],[11,"close","","Close an active data channel.",15,[[["self"]],["result",["error"]]]],[11,"wait_close","","Enter a temporary blocking state until the remote host closes the named channel.",15,[[["self"]],["result",["error"]]]],[11,"write","","",15,N],[11,"flush","","",15,[[["self"]],["result"]]],[11,"read","","",15,N],[11,"drop","","",15,[[["self"]]]],[11,"read","","",16,N],[11,"write","","",16,N],[11,"flush","","",16,[[["self"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"last_error","","Generate the last error that occurred for a `Session`.",17,[[["session"]],["option",["error"]]]],[11,"new","","Create a new error for the given code and message",17,[[["c_int"],["str"]],["error"]]],[11,"eof","","Generate an error that represents EOF",17,[[],["error"]]],[11,"unknown","","Generate an error for unknown failure",17,[[],["error"]]],[11,"from_errno","","Construct an error from an error code from libssh2",17,[[["c_int"]],["error"]]],[11,"message","","Get the message corresponding to this error",17,[[["self"]],["str"]]],[11,"code","","Return the code for this error",17,[[["self"]],["c_int"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"description","","",17,[[["self"]],["str"]]],[11,"from","","",17,[[["nulerror"]],["error"]]],[11,"read_file","","Reads a collection of known hosts from a specified file and adds them to the collection of known hosts.",18,[[["self"],["path"],["knownhostfilekind"]],["result",["u32","error"]]]],[11,"read_str","","Read a line as if it were from a known hosts file.",18,[[["self"],["str"],["knownhostfilekind"]],["result",["error"]]]],[11,"write_file","","Writes all the known hosts to the specified file using the specified file format.",18,[[["self"],["path"],["knownhostfilekind"]],["result",["error"]]]],[11,"write_string","","Converts a single known host to a single line of output for storage, using the 'type' output format.",18,[[["self"],["host"],["knownhostfilekind"]],["result",["string","error"]]]],[11,"iter","","Create an iterator over all of the known hosts in this structure.",18,[[["self"]],["hosts"]]],[11,"remove","","Delete a known host entry from the collection of known hosts.",18,[[["self"],["host"]],["result",["error"]]]],[11,"check","","Checks a host and its associated key against the collection of known hosts, and returns info back about the (partially) matched entry.",18,N],[11,"check_port","","Same as `check`, but takes a port as well.",18,N],[11,"add","","Adds a known host to the collection of known hosts.",18,N],[11,"drop","","",18,[[["self"]]]],[11,"next","","",19,[[["self"]],["option",["result"]]]],[11,"name","","This is `None` if no plain text host name exists.",20,[[["self"]],["option",["str"]]]],[11,"key","","Returns the key in base64/printable format",20,[[["self"]],["str"]]],[11,"accept","","Accept a queued connection from this listener.",21,[[["self"]],["result",["channel","error"]]]],[11,"drop","","",21,[[["self"]]]],[11,"new","","Initializes an SSH session object.",22,[[],["option",["session"]]]],[11,"set_banner","","Set the SSH protocol banner for the local client",22,[[["self"],["str"]],["result",["error"]]]],[11,"set_allow_sigpipe","","Flag indicating whether SIGPIPE signals will be allowed or blocked.",22,[[["self"],["bool"]]]],[11,"set_compress","","Flag indicating whether this library will attempt to negotiate compression.",22,[[["self"],["bool"]]]],[11,"set_blocking","","Set or clear blocking mode on session",22,[[["self"],["bool"]]]],[11,"is_blocking","","Returns whether the session was previously set to nonblocking.",22,[[["self"]],["bool"]]],[11,"set_timeout","","Set timeout for blocking functions.",22,[[["self"],["u32"]]]],[11,"timeout","","Returns the timeout, in milliseconds, for how long blocking calls may wait until they time out.",22,[[["self"]],["u32"]]],[11,"handshake","","Begin transport layer protocol negotiation with the connected host.",22,[[["self"],["tcpstream"]],["result",["error"]]]],[11,"userauth_password","","Attempt basic password authentication.",22,[[["self"],["str"],["str"]],["result",["error"]]]],[11,"userauth_agent","","Attempt to perform SSH agent authentication.",22,[[["self"],["str"]],["result",["error"]]]],[11,"userauth_pubkey_file","","Attempt public key authentication using a PEM encoded private key file stored on disk.",22,[[["self"],["str"],["option",["path"]],["path"],["option",["str"]]],["result",["error"]]]],[11,"userauth_pubkey_memory","","Attempt public key authentication using a PEM encoded private key from memory. Public key is computed from private key if none passed. This is available only for `unix` targets, as it relies on openssl. It is therefore recommended to use `#[cfg(unix)]` or otherwise test for the `unix` compliation target when using this function.",22,[[["self"],["str"],["option",["str"]],["str"],["option",["str"]]],["result",["error"]]]],[11,"userauth_hostbased_file","","",22,[[["self"],["str"],["path"],["path"],["option",["str"]],["str"],["option",["str"]]],["result",["error"]]]],[11,"authenticated","","Indicates whether or not the named session has been successfully authenticated.",22,[[["self"]],["bool"]]],[11,"auth_methods","","Send a SSH_USERAUTH_NONE request to the remote host.",22,[[["self"],["str"]],["result",["str","error"]]]],[11,"method_pref","","Set preferred key exchange method",22,[[["self"],["methodtype"],["str"]],["result",["error"]]]],[11,"methods","","Return the currently active algorithms.",22,[[["self"],["methodtype"]],["option",["str"]]]],[11,"supported_algs","","Get list of supported algorithms.",22,[[["self"],["methodtype"]],["result",["vec","error"]]]],[11,"agent","","Init an ssh-agent handle.",22,[[["self"]],["result",["agent","error"]]]],[11,"known_hosts","","Init a collection of known hosts for this session.",22,[[["self"]],["result",["knownhosts","error"]]]],[11,"channel_session","","Establish a new session-based channel.",22,[[["self"]],["result",["channel","error"]]]],[11,"channel_direct_tcpip","","Tunnel a TCP connection through an SSH session.",22,[[["self"],["str"],["u16"],["option"]],["result",["channel","error"]]]],[11,"channel_forward_listen","","Instruct the remote SSH server to begin listening for inbound TCP/IP connections.",22,[[["self"],["u16"],["option",["str"]],["option",["u32"]]],["result",["error"]]]],[11,"scp_recv","","Request a file from the remote host via SCP.",22,[[["self"],["path"]],["result",["error"]]]],[11,"scp_send","","Send a file to the remote host via SCP.",22,[[["self"],["path"],["i32"],["u64"],["option"]],["result",["channel","error"]]]],[11,"sftp","","Open a channel and initialize the SFTP subsystem.",22,[[["self"]],["result",["sftp","error"]]]],[11,"channel_open","","Allocate a new channel for exchanging data with the server.",22,[[["self"],["str"],["u32"],["u32"],["option",["str"]]],["result",["channel","error"]]]],[11,"banner","","Get the remote banner",22,[[["self"]],["option",["str"]]]],[11,"banner_bytes","","See `banner`.",22,[[["self"]],["option"]]],[11,"host_key","","Get the remote key.",22,[[["self"]],["option"]]],[11,"host_key_hash","","Returns the computed digest of the remote system's hostkey.",22,[[["self"],["hashtype"]],["option"]]],[11,"set_keepalive","","Set how often keepalive messages should be sent.",22,[[["self"],["bool"],["u32"]]]],[11,"keepalive_send","","Send a keepalive message if needed.",22,[[["self"]],["result",["u32","error"]]]],[11,"disconnect","","Terminate the transport layer.",22,[[["self"],["option",["disconnectcode"]],["str"],["option",["str"]]],["result",["error"]]]],[11,"rc","","Translate a return code into a Rust-`Result`.",22,[[["self"],["c_int"]],["result",["error"]]]],[11,"drop","","",22,[[["self"]]]],[11,"size","","Returns the size of the remote file.",23,[[["self"]],["u64"]]],[11,"mode","","Returns the listed mode of the remote file.",23,[[["self"]],["i32"]]],[11,"is_dir","","Returns whether the remote file is a directory.",23,[[["self"]],["bool"]]],[11,"is_file","","Returns whether the remote file is a regular file.",23,[[["self"]],["bool"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"clone","","",3,[[["self"]],["filestat"]]],[11,"eq","","",3,[[["self"],["filestat"]],["bool"]]],[11,"ne","","",3,[[["self"],["filestat"]],["bool"]]],[11,"eq","","",24,[[["self"],["openflags"]],["bool"]]],[11,"ne","","",24,[[["self"],["openflags"]],["bool"]]],[11,"clone","","",24,[[["self"]],["openflags"]]],[11,"partial_cmp","","",24,[[["self"],["openflags"]],["option",["ordering"]]]],[11,"lt","","",24,[[["self"],["openflags"]],["bool"]]],[11,"le","","",24,[[["self"],["openflags"]],["bool"]]],[11,"gt","","",24,[[["self"],["openflags"]],["bool"]]],[11,"ge","","",24,[[["self"],["openflags"]],["bool"]]],[11,"cmp","","",24,[[["self"],["openflags"]],["ordering"]]],[11,"hash","","",24,N],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"empty","","Returns an empty set of flags.",24,[[],["openflags"]]],[11,"all","","Returns the set containing all flags.",24,[[],["openflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",24,[[["self"]],["c_ulong"]]],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",24,[[["c_ulong"]],["option",["openflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",24,[[["c_ulong"]],["openflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",24,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",24,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",24,[[["self"],["openflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",24,[[["self"],["openflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",24,[[["self"],["openflags"]]]],[11,"remove","","Removes the specified flags in-place.",24,[[["self"],["openflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",24,[[["self"],["openflags"]]]],[11,"bitor","","Returns the union of the two sets of flags.",24,[[["self"],["openflags"]],["openflags"]]],[11,"bitor_assign","","Adds the set of flags.",24,[[["self"],["openflags"]]]],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",24,[[["self"],["openflags"]],["openflags"]]],[11,"bitxor_assign","","Toggles the set of flags.",24,[[["self"],["openflags"]]]],[11,"bitand","","Returns the intersection between the two sets of flags.",24,[[["self"],["openflags"]],["openflags"]]],[11,"bitand_assign","","Disables all flags disabled in the set.",24,[[["self"],["openflags"]]]],[11,"sub","","Returns the set difference of the two sets of flags.",24,[[["self"],["openflags"]],["openflags"]]],[11,"sub_assign","","Disables all flags enabled in the set.",24,[[["self"],["openflags"]]]],[11,"not","","Returns the complement of this set of flags.",24,[[["self"]],["openflags"]]],[11,"extend","","",24,[[["self"],["t"]]]],[11,"from_iter","","",24,[[["t"]],["openflags"]]],[11,"eq","","",25,[[["self"],["renameflags"]],["bool"]]],[11,"ne","","",25,[[["self"],["renameflags"]],["bool"]]],[11,"clone","","",25,[[["self"]],["renameflags"]]],[11,"partial_cmp","","",25,[[["self"],["renameflags"]],["option",["ordering"]]]],[11,"lt","","",25,[[["self"],["renameflags"]],["bool"]]],[11,"le","","",25,[[["self"],["renameflags"]],["bool"]]],[11,"gt","","",25,[[["self"],["renameflags"]],["bool"]]],[11,"ge","","",25,[[["self"],["renameflags"]],["bool"]]],[11,"cmp","","",25,[[["self"],["renameflags"]],["ordering"]]],[11,"hash","","",25,N],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"empty","","Returns an empty set of flags.",25,[[],["renameflags"]]],[11,"all","","Returns the set containing all flags.",25,[[],["renameflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",25,[[["self"]],["c_long"]]],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",25,[[["c_long"]],["option",["renameflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",25,[[["c_long"]],["renameflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",25,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",25,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",25,[[["self"],["renameflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",25,[[["self"],["renameflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",25,[[["self"],["renameflags"]]]],[11,"remove","","Removes the specified flags in-place.",25,[[["self"],["renameflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",25,[[["self"],["renameflags"]]]],[11,"bitor","","Returns the union of the two sets of flags.",25,[[["self"],["renameflags"]],["renameflags"]]],[11,"bitor_assign","","Adds the set of flags.",25,[[["self"],["renameflags"]]]],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",25,[[["self"],["renameflags"]],["renameflags"]]],[11,"bitxor_assign","","Toggles the set of flags.",25,[[["self"],["renameflags"]]]],[11,"bitand","","Returns the intersection between the two sets of flags.",25,[[["self"],["renameflags"]],["renameflags"]]],[11,"bitand_assign","","Disables all flags disabled in the set.",25,[[["self"],["renameflags"]]]],[11,"sub","","Returns the set difference of the two sets of flags.",25,[[["self"],["renameflags"]],["renameflags"]]],[11,"sub_assign","","Disables all flags enabled in the set.",25,[[["self"],["renameflags"]]]],[11,"not","","Returns the complement of this set of flags.",25,[[["self"]],["renameflags"]]],[11,"extend","","",25,[[["self"],["t"]]]],[11,"from_iter","","",25,[[["t"]],["renameflags"]]],[11,"clone","","",4,[[["self"]],["opentype"]]],[11,"open_mode","","Open a handle to a file.",26,[[["self"],["path"],["openflags"],["i32"],["opentype"]],["result",["file","error"]]]],[11,"open","","Helper to open a file in the `Read` mode.",26,[[["self"],["path"]],["result",["file","error"]]]],[11,"create","","Helper to create a file in write-only mode with truncation.",26,[[["self"],["path"]],["result",["file","error"]]]],[11,"opendir","","Helper to open a directory for reading its contents.",26,[[["self"],["path"]],["result",["file","error"]]]],[11,"readdir","","Convenience function to read the files in a directory.",26,[[["self"],["path"]],["result",["vec","error"]]]],[11,"mkdir","","Create a directory on the remote file system.",26,[[["self"],["path"],["i32"]],["result",["error"]]]],[11,"rmdir","","Remove a directory from the remote file system.",26,[[["self"],["path"]],["result",["error"]]]],[11,"stat","","Get the metadata for a file, performed by stat(2)",26,[[["self"],["path"]],["result",["filestat","error"]]]],[11,"lstat","","Get the metadata for a file, performed by lstat(2)",26,[[["self"],["path"]],["result",["filestat","error"]]]],[11,"setstat","","Set the metadata for a file.",26,[[["self"],["path"],["filestat"]],["result",["error"]]]],[11,"symlink","","Create a symlink at `target` pointing at `path`.",26,[[["self"],["path"],["path"]],["result",["error"]]]],[11,"readlink","","Read a symlink at `path`.",26,[[["self"],["path"]],["result",["pathbuf","error"]]]],[11,"realpath","","Resolve the real path for `path`.",26,[[["self"],["path"]],["result",["pathbuf","error"]]]],[11,"rename","","Rename a filesystem object on the remote filesystem.",26,[[["self"],["path"],["path"],["option",["renameflags"]]],["result",["error"]]]],[11,"unlink","","Remove a file on the remote filesystem",26,[[["self"],["path"]],["result",["error"]]]],[11,"last_error","","Peel off the last error to happen on this SFTP instance.",26,[[["self"]],["error"]]],[11,"rc","","Translates a return code into a Rust-`Result`",26,[[["self"],["c_int"]],["result",["error"]]]],[11,"drop","","",26,[[["self"]]]],[11,"setstat","","Set the metadata for this handle.",27,[[["self"],["filestat"]],["result",["error"]]]],[11,"stat","","Get the metadata for this handle.",27,[[["self"]],["result",["filestat","error"]]]],[11,"statvfs","","",27,[[["self"]],["result",["libssh2_sftp_statvfs","error"]]]],[11,"readdir","","Reads a block of data from a handle and returns file entry information for the next entry, if any.",27,[[["self"]],["result",["error"]]]],[11,"fsync","","This function causes the remote server to synchronize the file data and metadata to disk (like fsync(2)).",27,[[["self"]],["result",["error"]]]],[11,"read","","",27,N],[11,"write","","",27,N],[11,"flush","","",27,[[["self"]],["result"]]],[11,"seek","","Move the file handle's internal pointer to an arbitrary location.",27,[[["self"],["seekfrom"]],["result",["u64"]]]],[11,"drop","","",27,[[["self"]]]],[11,"file_type","","Returns the file type for this filestat.",3,[[["self"]],["filetype"]]],[11,"is_dir","","Returns whether this metadata is for a directory.",3,[[["self"]],["bool"]]],[11,"is_file","","Returns whether this metadata is for a regular file.",3,[[["self"]],["bool"]]],[11,"from_raw","","Creates a new instance of a stat from a raw instance.",3,[[["libssh2_sftp_attributes"]],["filestat"]]],[11,"raw","","Convert this stat structure to its raw representation.",3,[[["self"]],["libssh2_sftp_attributes"]]],[11,"is_dir","","Test whether this file type represents a directory.",28,[[["self"]],["bool"]]],[11,"is_file","","Test whether this file type represents a regular file.",28,[[["self"]],["bool"]]],[11,"is_symlink","","Test whether this file type represents a symbolic link.",28,[[["self"]],["bool"]]],[7,"FLUSH_EXTENDED_DATA","","When passed to `Channel::flush_stream`, flushes all extended data substreams.",N,N],[7,"FLUSH_ALL","","When passed to `Channel::flush_stream`, flushes all substream.",N,N],[7,"EXTENDED_DATA_STDERR","","Stream ID of the stderr channel for stream-related methods on `Channel`",N,N],[17,"READ","","Open the file for reading.",N,N],[17,"WRITE","","Open the file for writing. If both this and Read are specified, the file is opened for both reading and writing",N,N],[17,"APPEND","","Force all writes to append data at the end of the file.",N,N],[17,"CREATE","","If this flag is specified, then a new file will be created if one does not already exist (if Truncate is specified, the new file will be truncated to zero length if it previously exists) ",N,N],[17,"TRUNCATE","","Forces an existing file with the same name to be truncated to zero length when creating a file by specifying `Create`. Using this flag implies the `Create` flag.",N,N],[17,"EXCLUSIVE","","Causes the request to fail if the named file already exists. Using this flag implies the `Create` flag.",N,N],[17,"ATOMIC","","Inform the remote that an atomic rename operation is desired if available",N,N],[17,"OVERWRITE","","In a rename operation, overwrite the destination if it already exists. If this flag is not present then it is an error if the destination already exists",N,N],[17,"NATIVE","","Inform the remote end that the native system calls for renaming should be used",N,N],[11,"clone","","",5,[[["self"]],["disconnectcode"]]],[11,"clone","","",6,[[["self"]],["hostkeytype"]]],[11,"clone","","",7,[[["self"]],["methodtype"]]],[11,"clone","","",8,[[["self"]],["hashtype"]]],[11,"clone","","",9,[[["self"]],["knownhostfilekind"]]],[11,"clone","","",10,[[["self"]],["checkresult"]]],[11,"clone","","",11,[[["self"]],["knownhostkeyformat"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,N],[11,"from","","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]]],"paths":[[3,"ExitSignal"],[3,"ReadWindow"],[3,"WriteWindow"],[3,"FileStat"],[4,"OpenType"],[4,"DisconnectCode"],[4,"HostKeyType"],[4,"MethodType"],[4,"HashType"],[4,"KnownHostFileKind"],[4,"CheckResult"],[4,"KnownHostKeyFormat"],[3,"Agent"],[3,"Identities"],[3,"PublicKey"],[3,"Channel"],[3,"Stream"],[3,"Error"],[3,"KnownHosts"],[3,"Hosts"],[3,"Host"],[3,"Listener"],[3,"Session"],[3,"ScpFileStat"],[3,"OpenFlags"],[3,"RenameFlags"],[3,"Sftp"],[3,"File"],[3,"FileType"]]};
initSearch(searchIndex);
